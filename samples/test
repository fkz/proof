// Wahrheitswerte
False := (A: Set) -> A;
True := (A: Set) -> A -> A;
I: True := (A: Set) (a: A) => a;

bool := (A: Set) -> A -> A -> A;
false: bool := (A: Set) (a b: A) => a;
true: bool := (A: Set) (a b: A) => b;
not: bool -> bool := (b: bool) => b bool true false;


nat := (A: Set) -> (A -> A) -> A -> A;
0: nat := (A: Set) (s: A -> A) (o: A) => o;
S: nat -> nat := (pred: nat) (A: Set) (s: A -> A) (o: A) => s (pred A s o);
1: nat := S 0;
1': nat := (A: Set) (s: A -> A) (o: A) => s o;
2: nat := S (S 0);
3: nat := S (S (S 0));

print ? 3;

add: nat -> nat -> nat := (a: nat) (b: nat) => a nat ((q: nat) => S q) b;
mul: nat -> nat -> nat := (a: nat) (b: nat) => a nat ((q: nat) => add q b) 0;
exp: nat -> nat -> nat := (a: nat) (b: nat) => b nat ((q: nat) => mul q a) 1;


pair: Set -> Set -> Set := (A: Set) => (B: Set) => (s: Set) -> (A -> B -> s) -> s;
mkpair: (A: Set) (B: Set) -> A -> B -> pair A B := (A: Set) (B: Set) (a: A) (b: B) => (s: Set) (z: A -> B -> s) => z a b;
first: (A: Set) (B: Set) -> pair A B -> A := (A: Set) (B: Set) (p: pair A B) => p A ((a: A) (b: B) => a);
second: (A: Set) (B: Set) -> pair A B -> B := (A: Set) (B: Set) (p: pair A B) => p B ((a: A) (b: B) => b);

vorgaenger: nat -> nat := (n: nat) => first nat bool (n (pair nat bool) ((x: pair nat bool) => mkpair nat bool ((second nat bool x) nat 0 (S (first nat bool x))) true) (mkpair nat bool 0 false));
v0: nat := vorgaenger 0;

//print ? (vorgaenger (mul 2 3));
print exp 3 (exp 3 (exp 3 3));
print ? exp 2 3;

2^8=3*3-1 ? exp 2 3 ? vorgaenger (mul 3 3);
10 ? 1 ? 0;
1v0 ? 1 ? vorgaenger 2;
1v1 ? 2 ? vorgaenger 2;
0v0 ? 0 ? vorgaenger 0;

klar := 0 nat ((x: nat) => x) 0;

//CheckO ? O ? klar;